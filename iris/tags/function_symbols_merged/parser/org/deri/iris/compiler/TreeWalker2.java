/*
 * Integrated Rule Inference System (IRIS):
 * An extensible rule inference system for datalog with extensions by 
 * built-in predicates, default negation (under well-founded semantics), 
 * function symbols and contexts. 
 * 
 * Copyright (C) 2006  Digital Enterprise Research Institute (DERI), 
 * Leopold-Franzens-Universitaet Innsbruck, Technikerstrasse 21a, 
 * A-6020 Innsbruck. Austria.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
 * MA  02110-1301, USA.
 */
package org.deri.iris.compiler;

import static org.deri.iris.factory.Factory.BASIC;
import static org.deri.iris.factory.Factory.BUILTIN;
import static org.deri.iris.factory.Factory.CONCRETE;
import static org.deri.iris.factory.Factory.TERM;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.deri.iris.api.basics.IAtom;
import org.deri.iris.api.basics.ILiteral;
import org.deri.iris.api.basics.IPredicate;
import org.deri.iris.api.basics.IQuery;
import org.deri.iris.api.basics.IRule;
import org.deri.iris.api.basics.ITuple;
import org.deri.iris.api.terms.ITerm;
import org.deri.iris.builtins.BuiltinRegister;
import org.deri.iris.new_stuff.storage.IRelation;
import org.deri.iris.new_stuff.storage.simple.SimpleRelationFactory;
import org.deri.iris.parser.analysis.DepthFirstAdapter;
import org.deri.iris.parser.node.ABase64binaryTerm;
import org.deri.iris.parser.node.ABinaryBuiltin;
import org.deri.iris.parser.node.ABooleanTerm;
import org.deri.iris.parser.node.ABuiltinLiteral;
import org.deri.iris.parser.node.ADateTerm;
import org.deri.iris.parser.node.ADatetimeTerm;
import org.deri.iris.parser.node.ADecimalTerm;
import org.deri.iris.parser.node.ADecimallTerm;
import org.deri.iris.parser.node.ADoubleTerm;
import org.deri.iris.parser.node.ADurationTerm;
import org.deri.iris.parser.node.AEqualsBuiltin;
import org.deri.iris.parser.node.AFact;
import org.deri.iris.parser.node.AFloatTerm;
import org.deri.iris.parser.node.AFunctionTerm;
import org.deri.iris.parser.node.AGdayTerm;
import org.deri.iris.parser.node.AGmonthTerm;
import org.deri.iris.parser.node.AGmonthdayTerm;
import org.deri.iris.parser.node.AGyearTerm;
import org.deri.iris.parser.node.AGyearmonthTerm;
import org.deri.iris.parser.node.AHexbinaryTerm;
import org.deri.iris.parser.node.AIntIntlist;
import org.deri.iris.parser.node.AIntegerTerm;
import org.deri.iris.parser.node.AIntegerlTerm;
import org.deri.iris.parser.node.AIntlist;
import org.deri.iris.parser.node.AIriTerm;
import org.deri.iris.parser.node.AIrilTerm;
import org.deri.iris.parser.node.ALiteral;
import org.deri.iris.parser.node.ALitlist;
import org.deri.iris.parser.node.ANegatedLiteral;
import org.deri.iris.parser.node.ANegatedbuiltinLiteral;
import org.deri.iris.parser.node.APredicate;
import org.deri.iris.parser.node.AQuery;
import org.deri.iris.parser.node.ARule;
import org.deri.iris.parser.node.ASqnameTerm;
import org.deri.iris.parser.node.ASqnamelTerm;
import org.deri.iris.parser.node.AStringTerm;
import org.deri.iris.parser.node.AStringlTerm;
import org.deri.iris.parser.node.ATernaryBuiltin;
import org.deri.iris.parser.node.ATimeTerm;
import org.deri.iris.parser.node.AVarTerm;
import org.deri.iris.parser.node.PIntlist;

/**
 * Traverses the abstract syntax tree generated by SableCC and constructs
 * the components of a logic program, i.e. facts, rules and queries.
 */
public class TreeWalker2 extends DepthFirstAdapter
{
    public TreeWalker2( BuiltinRegister builtinRegister )
    {
    	mBuiltinRegister = builtinRegister;
    }

    public Map<IPredicate,IRelation> getFacts()
    {
    	return mFacts;
    }

    public List<IRule> getRuleBase()
    {
    	return mRules;
    }
    
    public List<IQuery> getQueries()
    {
    	return mQueries;
    }
    
    public void inALitlist(final ALitlist l) {
	    super.inALitlist(l);

	    literals = new ArrayList<ILiteral>();
    }

    public void inALiteral(final ALiteral l) {
	    super.inALiteral(l);
    }

    @Override
    public void inAPredicate( APredicate arg0 )
    {
	    super.inAPredicate( arg0 );
	    pushTerms();
    }

	public void inABuiltinLiteral(final ABuiltinLiteral l) {
	    super.inABuiltinLiteral(l);

	    pushTerms();
    }

    public void inANegatedLiteral(final ANegatedLiteral l) {
	    super.inANegatedLiteral(l);
    }

    public void inANegatedbuiltinLiteral(final ANegatedbuiltinLiteral l) {
	    super.inANegatedbuiltinLiteral(l);
	    pushTerms();
    }
    
    public void inAFunctionTerm(final AFunctionTerm t) {
	    super.inAFunctionTerm(t);

	    pushTerms();
    }

    public void inAFact(final AFact f) {
	    super.inAFact(f);

	    literals = new ArrayList<ILiteral>();
    }

    public void inAQuery(final AQuery q) {
	    super. inAQuery(q);

	    literals = new ArrayList<ILiteral>();
    }

    public void inARule(final ARule r) {
	    super.inARule(r);

	    literals = new ArrayList<ILiteral>();
    }

    public void outARule(final ARule r) {
    	super.outARule(r);

    	r.getHead().apply(this);
    	final List<ILiteral> head = new ArrayList<ILiteral>(literals);
		
    	List<ILiteral> body = new ArrayList<ILiteral>();
    	if( r.getBody() != null )
    	{
    		r.getBody().apply(this);
    		body.addAll( literals );
    	}
		mRules.add(BASIC.createRule(head, body));
    }
    
    public void outAFact(final AFact f)
    {
    	super.outAFact(f);

    	IAtom atom = literals.get(0).getAtom();
    	addFact( atom.getPredicate(), atom.getTuple() );
    }
    
    private void addFact( IPredicate predicate, ITuple tuple )
    {
    	IRelation relation = mFacts.get( predicate );
    	
    	if( relation == null )
    	{
    		relation = new SimpleRelationFactory().createRelation();
    		mFacts.put( predicate, relation );
    	}
    	
    	relation.add( tuple );
    }

    public void outAQuery(final AQuery _q)
    {
    	super.outAQuery(_q);

    	mQueries.add(BASIC.createQuery(literals));
    }
    
    public void outANegatedLiteral(ANegatedLiteral _l) {
	    final ILiteral neg = BASIC.createLiteral(false, 
			    literals.get(literals.size() - 1).getAtom());
	    literals.set(literals.size() - 1, neg);
    }
    
    public void outANegatedbuiltinLiteral( ANegatedbuiltinLiteral arg0 ) {
	    final ILiteral neg = BASIC.createLiteral(false, 
			    literals.get(literals.size() - 1).getAtom());
	    literals.set(literals.size() - 1, neg);
    }

	public void outABinaryBuiltin(final ABinaryBuiltin b) {
    	final String op = b.getTBinOp().getText().trim();
    	
    	List<ITerm> terms = popTerms();
    	
    	if (op.equals(">")) {
    		literals.add(BASIC.createLiteral(true, 
					BUILTIN.createGreater(terms.get(0), terms.get(1))));
    	} else if (op.equals(">=")) {
    		literals.add(BASIC.createLiteral(true, 
					BUILTIN.createGreaterEqual(terms.get(0), terms.get(1))));
    	} else if (op.equals("<")) {
    		literals.add(BASIC.createLiteral(true, 
					BUILTIN.createLess(terms.get(0), terms.get(1))));
    	} else if (op.equals("<=")) {
    		literals.add(BASIC.createLiteral(true, 
					BUILTIN.createLessEqual(terms.get(0), terms.get(1))));
    	} else if (op.equals("!=")) {
    		literals.add(BASIC.createLiteral(true, 
					BUILTIN.createUnequal(terms.get(0), terms.get(1))));
    	} else {
    		throw new IllegalArgumentException("Couldn't handle the operator " + op);
    	}
    }

    public void outAEqualsBuiltin(final AEqualsBuiltin b) {
    	List<ITerm> terms = popTerms();
    	literals.add(BASIC.createLiteral(true, BUILTIN.createEqual(terms.get(0), terms.get(1))));
    }

    
    public void outATernaryBuiltin(final ATernaryBuiltin b) {
    	final String op = b.getTTerOp().getText().trim();

    	List<ITerm> terms = popTerms();

    	if (op.equals("+")) {
			literals.add(BASIC.createLiteral(true, BUILTIN.createAddBuiltin(
							terms.get(0), terms.get(1), terms.get(2))));
		} else if (op.equals("-")) {
			literals.add(BASIC.createLiteral(true, BUILTIN.createSubtractBuiltin(
							terms.get(0), terms.get(1), terms.get(2))));
		} else if (op.equals("*")) {
			literals.add(BASIC.createLiteral(true, BUILTIN.createMultiplyBuiltin(
							terms.get(0), terms.get(1), terms.get(2))));
		} else if (op.equals("/")) {
			literals.add(BASIC.createLiteral(true, BUILTIN.createDivideBuiltin(
							terms.get(0), terms.get(1), terms.get(2))));
		} else if (op.equals("%")) {
			literals.add(BASIC.createLiteral(true, BUILTIN.createModulusBuiltin(
							terms.get(0), terms.get(1), terms.get(2))));
		} else {
	    		throw new IllegalArgumentException("Couldn't handle the operator " + op);
		}
    }
    
	
    public void outAPredicate(final APredicate p)
    {
    	super.outAPredicate(p);
		final String symbol = p.getTId().getText().trim();
		final IAtom a;
		final Class<?> builtinClass = mBuiltinRegister.getBuiltinClass(symbol);
	
		List<ITerm> terms = popTerms();
	
		if (builtinClass == null)
		{ // this predicate is not a builtin
			a = BASIC.createAtom(
					BASIC.createPredicate(symbol, terms.size()), 
					BASIC.createTuple(terms));
		}
		else
		{ // the predicate is a builtin
			try
			{
				a = (IAtom) builtinClass.getConstructor(ITerm[].class).
					newInstance(new Object[]{terms.toArray(new ITerm[terms.size()])});
			}
			catch (Exception e)
			{
				throw new IllegalArgumentException( "Can not get the java class for the built-in: " + builtinClass + ", " +e );
			}
	    }
    	literals.add(BASIC.createLiteral(true, a) );
    }
    
    public void outAVarTerm(AVarTerm v) {
    	super.outAVarTerm(v);

    	final String n = v.getTVariable().getText().trim();
    	addTerm(TERM.createVariable(n.startsWith("?") ? n.substring(1) : n));
    }

	public void outAFunctionTerm(AFunctionTerm ft)
	{
		super.outAFunctionTerm(ft);
		
		String name = peeleStr( ft.getTId().getText().trim() );
		List<ITerm> terms = popTerms();
		
		addTerm( TERM.createConstruct( name, terms ) );
	}
	
	/**
	 * Transforms a intlist to an array of integers.
	 * @param l the intlist to transform
	 * @return the transformed integer array
	 * @throws NullPointerException if the intlist is {@code null}
	 * @throws IllegalArgumentException if somewhere along the transformation an object
	 * 	appears, which vould not be handeled.
	 */
	private static Integer[] transfromIntList(final PIntlist l) {
		if (l == null) {
			throw new NullPointerException("The intlist must not be null");
		}
		
		final List<Integer> ints = new LinkedList<Integer>();
		PIntlist a = l;
		while (a != null) {
			if (a instanceof AIntIntlist) {
				ints.add(Integer.parseInt(((AIntIntlist) a).getTInt().getText().trim()));
				a = null;
			} else if (a instanceof AIntlist) {
				AIntlist il = (AIntlist) a;
				ints.add(Integer.parseInt(il.getTInt().getText().trim()));
				a = il.getIntlist();
			} else {
				throw new IllegalArgumentException("Couldn't handle a object of type " + a.getClass().getName());
			}
		}

		Collections.reverse(ints);
		final Integer[] arr = new Integer[ints.size()];
		return ints.toArray(arr);
	}

	public void outAStringTerm(final AStringTerm st) {
		addTerm(TERM.createString(peeleStr(st.getTStr().toString().trim())));
	}

	public void outAStringlTerm(final AStringlTerm st) {
		addTerm(TERM.createString(peeleStr(st.getTStr().toString().trim())));
	}

	public void outAIntegerTerm(final AIntegerTerm it) {
		addTerm(CONCRETE.createInteger(Integer.parseInt(it.getTInt().toString().trim())));
	}

	public void outAIntegerlTerm(final AIntegerlTerm it) {
		addTerm(CONCRETE.createInteger(Integer.parseInt(it.getTInt().toString().trim())));
	}

	public void outADecimalTerm(final ADecimalTerm dt) {
		addTerm(CONCRETE.createDecimal(Double.parseDouble(dt.getTDec().toString().trim())));
	}

	public void outADecimallTerm(final ADecimallTerm dt) {
		addTerm(CONCRETE.createDecimal(Double.parseDouble(dt.getTDec().toString().trim())));
	}

	public void outASqnameTerm(final ASqnameTerm st) {
		addTerm(CONCRETE.createSqName(st.getTSq().toString().trim()));
	}

	public void outASqnamelTerm(final ASqnamelTerm st) {
		addTerm(CONCRETE.createSqName(st.getTSq().toString().trim()));
	}

	public void outAIriTerm(final AIriTerm i) {
		addTerm(CONCRETE.createIri(peeleStr(i.getTStr().toString().trim())));
	}

	public void outAIrilTerm(final AIrilTerm i) {
		addTerm(CONCRETE.createIri(peeleStr(i.getTStr().toString().trim())));
	}

	public void outABooleanTerm(final ABooleanTerm b) {
		String value = peeleStr(b.getTStr().toString().trim());
		addTerm(CONCRETE.createBoolean( value ) );
	}

	public void outADoubleTerm(final ADoubleTerm d) {
		addTerm(CONCRETE.createDouble(Double.parseDouble(d.getTDec().toString().trim())));
	}

	public void outAFloatTerm(final AFloatTerm f) {
		addTerm(CONCRETE.createFloat(Float.parseFloat(f.getTDec().toString().trim())));
	}

	public void outABase64binaryTerm(final ABase64binaryTerm b) {
		addTerm(CONCRETE.createBase64Binary(peeleStr(b.getTStr().getText().trim())));
	}

	public void outAHexbinaryTerm(final AHexbinaryTerm h) {
		addTerm(CONCRETE.createHexBinary(peeleStr(h.getTStr().getText().trim())));
	}

	public void outADateTerm(final ADateTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length == 3) {
			addTerm(CONCRETE.createDate(params[0], params[1], params[2]));
		} else if (params.length == 5) {
			addTerm(CONCRETE.createDate(params[0], params[1], params[2], params[3], params[4]));
		} else {
			throw new IllegalArgumentException("The number of integers in a date must be 3 or 5, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outADurationTerm(final ADurationTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length == 6) {
			addTerm(CONCRETE.createDuration(params[0], params[1], params[2], 
						params[3], params[4], params[5]));
		} else if (params.length == 7) {
			addTerm(CONCRETE.createDuration(params[0], params[1], params[2], 
						params[3], params[4], params[5], params[6]));
		} else {
			throw new IllegalArgumentException("The number of integers in a duration must be 6 or 7, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outADatetimeTerm(final ADatetimeTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length == 6) {
			addTerm(CONCRETE.createDateTime(params[0], params[1], params[2], params[3], params[4], params[5]));
		} else if (params.length == 8) {
			addTerm(CONCRETE.createDateTime(params[0], params[1], params[2], params[3], params[4], params[5], 
						params[6], params[7]));
		} else if (params.length == 9) {
			addTerm(CONCRETE.createDateTime(params[0], params[1], params[2], params[3], params[4], params[5], 
						params[6], params[7], params[8]));
		} else {
			throw new IllegalArgumentException("The number of integers in a datetime must be 6, 8 or 9, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outATimeTerm(final ATimeTerm t) {
		Integer[] params = transfromIntList(t.getIntlist());
		if (params.length == 3) {
			addTerm(CONCRETE.createTime(params[0], params[1], params[2]));
		} else if (params.length == 5) {
			addTerm(CONCRETE.createTime(params[0], params[1], params[2], params[3], params[4]));
		} else if (params.length == 6) {
			addTerm(CONCRETE.createTime(params[0], params[1], params[2], params[3], params[4], params[5]));
		} else {
			throw new IllegalArgumentException("The number of integers in a time must be 3, 5 or 6, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outAGyearTerm(final AGyearTerm g) {
		addTerm(CONCRETE.createGYear(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGmonthTerm(final AGmonthTerm g) {
		addTerm(CONCRETE.createGMonth(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGdayTerm(final AGdayTerm g) {
		addTerm(CONCRETE.createGDay(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGyearmonthTerm(final AGyearmonthTerm g) {
		Integer[] params = transfromIntList(g.getIntlist());
		if (params.length != 2) {
			throw new IllegalArgumentException("The number of integers in a gyearmonth must be 2, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		addTerm(CONCRETE.createGYearMonth(params[0], params[1]));
	}

	public void outAGmonthdayTerm(final AGmonthdayTerm g) {
		Integer[] params = transfromIntList(g.getIntlist());
		if (params.length != 2) {
			throw new IllegalArgumentException("The number of integers in a gmonthday must be 2, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		addTerm(CONCRETE.createGMonthDay(params[0], params[1]));
	}

	/**
	 * Removes the leading and tailing <code>&amp;'&amp;</code> from a
	 * string.
	 * @param s the string to peele
	 * @return the peeled stirng if the string started and ended with 
	 * 	a <code>&amp;'&amp;</code>, otherwise the input string will be returned.
	 * @throws NullPointerException if the string is <code>null</code>
	 */
	private static String peeleStr(final String s) {
		if(s == null) {
			throw new NullPointerException("The string must not be null");
		}
		return ((s.charAt(0) == '\'') && (s.charAt(s.length() - 1) == '\'')) ? 
			s.substring(1, s.length() - 1) : s;
	}
	
	private void pushTerms()
	{
		mTermStack.add( new ArrayList<ITerm>() );
	}

	private void addTerm( ITerm term )
	{
		mTermStack.get( mTermStack.size() - 1 ).add( term );
	}

	private List<ITerm> popTerms()
	{
		int last = mTermStack.size() - 1;
		
		List<ITerm> result = mTermStack.get( last );
		mTermStack.remove( last );
		
		return result;
	}

	private List<List<ITerm>> mTermStack = new ArrayList<List<ITerm>>();

	private List<ILiteral> literals;
	
    private Map<IPredicate,IRelation> mFacts = new HashMap<IPredicate,IRelation>();
    private List<IRule> mRules = new ArrayList<IRule>();
    private List<IQuery> mQueries = new ArrayList<IQuery>();
    
    private final BuiltinRegister mBuiltinRegister;
}
