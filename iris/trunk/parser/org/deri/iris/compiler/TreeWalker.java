/*
 * Integrated Rule Inference System (IRIS):
 * An extensible rule inference system for datalog with extensions by 
 * built-in predicates, default negation (under well-founded semantics), 
 * function symbols and contexts. 
 * 
 * Copyright (C) 2006  Digital Enterprise Research Institute (DERI), 
 * Leopold-Franzens-Universitaet Innsbruck, Technikerstrasse 21a, 
 * A-6020 Innsbruck. Austria.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
 * MA  02110-1301, USA.
 */
package org.deri.iris.compiler;

import java.util.*;

import org.deri.iris.parser.analysis.DepthFirstAdapter;
import org.deri.iris.parser.node.*;
import org.deri.iris.basics.*;
import org.deri.iris.api.terms.ITerm;
import org.deri.iris.api.*;
import org.deri.iris.api.basics.*;
import org.deri.iris.factory.*;
import org.deri.iris.api.builtins.*;
import org.deri.iris.basics.seminaive.EqualityLiteral;

/**
 * traverses AST generated by SbaleCC and populates RuleSet
 *
 * <pre>
 * Created on 14.11.2005
 * Committed by $Author: franciscogarcia $
 * $Source: /tmp/iris-cvsbackup/iris/parser/org/deri/iris/compiler/TreeWalker.java,v $,
 * </pre>
 *
 * @author Francisco Garcia
 *
 * @version $Revision: 1.8 $ $Date: 2006-09-19 22:53:13 $
 */
public class TreeWalker extends DepthFirstAdapter {
    
	Vector<ITerm> terms = new Vector<ITerm>(); 
	Vector<ILiteral> literals = new Vector<ILiteral>();
	
    private IEDB p;
	
    public TreeWalker(IEDB p){
        this.p= p;
    }
    
    public IAtom getLastFact() {
    	return Factory.BASIC.createAtom(Factory.BASIC.createPredicate("test",0));
    }
    
    public IRule getLastRule() {
    	return Factory.BASIC.createRule(Factory.BASIC.createHead(literals), Factory.BASIC.createBody(literals));
    }
    
    public void outARule(ARule _r) 
    {
    	super.outARule(_r);
    	// Initialite literals
    	literals = new Vector<ILiteral>();
    	// Initialite terms
    	terms = new Vector<ITerm>();
    	_r.getPredicate().apply(this);
    	IHead ruleHead = Factory.BASIC.createHead(literals);
    	// Initialite literals
    	literals = new Vector<ILiteral>();
    	// Initialite terms
    	terms = new Vector<ITerm>();
   	 	_r.getBody().apply(this);
   	 	IBody ruleBody = Factory.BASIC.createBody(literals);
    	IRule r = Factory.BASIC.createRule(ruleHead, ruleBody);
     	p.addRule(r);

    	// Initialite literals
    	literals = new Vector<ILiteral>();
    	// Initialite terms
    	terms = new Vector<ITerm>();

    }
    
    public void outAFact(AFact _f)
    {
    	super.outAFact(_f);
    	// Initialite literals
    	//literals = new Vector<ILiteral>();
    	// Initialite terms
    	//terms = new Vector<ITerm>();
    	//_f.getPredicate().apply(this);
    	p.addFact(literals.firstElement().getAtom());
    	
    	// Initialite literals
    	literals = new Vector<ILiteral>();
    	// Initialite terms
    	terms = new Vector<ITerm>();
    }
    
    public void outAQuery(AQuery _q)
    {
    	super.outAQuery(_q);
    	// Initialite literals
    	//literals = new Vector<ILiteral>();
    	// Initialite terms
    	//terms = new Vector<ITerm>();
    	//_q.getBody().apply(this);
    	IQuery q = Factory.BASIC.createQuery(literals);
    	p.addQuery(q);
    	// Initialite literals
    	literals = new Vector<ILiteral>();
    	// Initialite terms
    	terms = new Vector<ITerm>();
    }
    
    public void outANegatedLiteral(ANegatedLiteral _l)
    {
    	((ILiteral)literals.lastElement()).setPositive(false);
    }
    
    public void outAEqvarBuiltin(AEqvarBuiltin _b)
    {
    	super.outAEqvarBuiltin(_b);
    	List<ITerm> terms = new LinkedList<ITerm>();
    	ITerm t1 = Factory.TERM.createVariable(_b.getFirst().getText().trim());
    	ITerm t2 = Factory.TERM.createVariable(_b.getSecond().getText().trim());
    	terms.add(t1);
    	terms.add(t2);
    	ITuple tuple = Factory.BASIC.createTuple(terms);
    	ILiteral l = Factory.BASIC.createEqualityLiteral(true, EqualityLiteral.EQUALS, tuple); 
    	literals.add(l);    	
    }
    
    public void outANeqvarBuiltin(ANeqvarBuiltin _b)
    {
    	super.outANeqvarBuiltin(_b);
    	List<ITerm> terms = new LinkedList<ITerm>();
    	ITerm t1 = Factory.TERM.createVariable(_b.getFirst().getText().trim());
    	ITerm t2 = Factory.TERM.createVariable(_b.getSecond().getText().trim());
    	terms.add(t1);
    	terms.add(t2);
    	ITuple tuple = Factory.BASIC.createTuple(terms);
    	ILiteral l = Factory.BASIC.createEqualityLiteral(false, EqualityLiteral.EQUALS, tuple); 
    	literals.add(l);    	
    }
 
    public void outAEqidBuiltin(AEqidBuiltin _b)
    {
    	super.outAEqidBuiltin(_b);
    	List<ITerm> terms = new LinkedList<ITerm>();
    	ITerm t1 = Factory.TERM.createVariable(_b.getTVariable().getText().trim());
    	ITerm t2 = Factory.TERM.createString(_b.getTId().getText().trim());
    	terms.add(t1);
    	terms.add(t2);
    	ITuple tuple = Factory.BASIC.createTuple(terms);
    	ILiteral l = Factory.BASIC.createEqualityLiteral(true, EqualityLiteral.EQUALS, tuple); 
    	literals.add(l);    	
    }
 
    public void outANeqidBuiltin(ANeqidBuiltin _b)
    {
    	super.outANeqidBuiltin(_b);
    	List<ITerm> terms = new LinkedList<ITerm>();
    	ITerm t1 = Factory.TERM.createVariable(_b.getTVariable().getText().trim());
    	ITerm t2 = Factory.TERM.createString(_b.getTId().getText().trim());
    	terms.add(t1);
    	terms.add(t2);
    	ITuple tuple = Factory.BASIC.createTuple(terms);
    	ILiteral l = Factory.BASIC.createEqualityLiteral(false, EqualityLiteral.EQUALS, tuple); 
    	literals.add(l);    	
    }
    
    public void outAPredicate(APredicate _p)
    {
    	super.outAPredicate(_p);
     	IPredicate p = Factory.BASIC.createPredicate(_p.getTId().getText().trim(), terms.size() /*arity*/);
    	IAtom a = Factory.BASIC.createAtom(p, Factory.BASIC.createTuple(terms));
    	// Initialite terms
    	terms = new Vector<ITerm>();
    	ILiteral l = Factory.BASIC.createLiteral(true, a); 
    	literals.add(l);
    }
    
    public void outAConstantTerm(AConstantTerm _ct)
    {
    	super.outAConstantTerm(_ct);
    	ITerm t = Factory.TERM.createString(_ct.getTId().getText().trim());
    	terms.add(t);    	
    }
    
    public void outAVarTerm(AVarTerm _vt)
    {
    	super.outAVarTerm(_vt);
    	ITerm t = Factory.TERM.createVariable(_vt.getTVariable().getText().trim());
    	terms.add(t);
    }

	public void outAFunctionTerm(AFunctionTerm _ft)
	{
		super.outAFunctionTerm(_ft);
		
    	Vector<ITerm> terms_temporal = terms;
		terms = new Vector<ITerm>(); 
		_ft.getParamlist().apply(this);
		ITerm t = Factory.TERM.createConstruct(_ft.getTId().getText().trim(), terms);
		// Delete the terms of the current function from the global terms list
		for (int i = 0; i < terms.size(); i++)
		{
			terms_temporal.remove(terms_temporal.size() - 1);
		}
		// Restore terms
		terms = terms_temporal;
		terms.add(t);
	}

}

