/*
 * Integrated Rule Inference System (IRIS):
 * An extensible rule inference system for datalog with extensions by 
 * built-in predicates, default negation (under well-founded semantics), 
 * function symbols and contexts. 
 * 
 * Copyright (C) 2006  Digital Enterprise Research Institute (DERI), 
 * Leopold-Franzens-Universitaet Innsbruck, Technikerstrasse 21a, 
 * A-6020 Innsbruck. Austria.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
 * MA  02110-1301, USA.
 */
package org.deri.iris.compiler;

import static org.deri.iris.factory.Factory.BASIC;
import static org.deri.iris.factory.Factory.TERM;
import static org.deri.iris.factory.Factory.CONCRETE;
import static org.deri.iris.factory.Factory.BUILTIN;
import static org.deri.iris.factory.Factory.PROGRAM;

import java.util.*;

import org.deri.iris.parser.analysis.DepthFirstAdapter;
import org.deri.iris.parser.node.*;
import org.deri.iris.api.terms.ITerm;
import org.deri.iris.api.*;
import org.deri.iris.api.basics.*;
import org.deri.iris.factory.*;

/**
 * <p>
 * Traverses AST generated by SbaleCC and constructs a program.
 * </p>
 * <p>
 * $Id: TreeWalker.java,v 1.14 2007-04-05 09:17:19 poettler_ric Exp $
 * </p>
 * @author Francisco Garcia
 * @author Richard PÃ¶ttler, richard dot poettler at deri dot org
 * @version $Revision: 1.14 $
 */
public class TreeWalker extends DepthFirstAdapter {
    
	private List<ITerm> terms;
	private List<ILiteral> literals;
	private boolean inFunc = false;
	private List<ITerm> func_terms;
	
    private IProgram p;
	
    public TreeWalker(IProgram p){
        this.p = (p == null) ? PROGRAM.createProgram() : p;
    }

    //
    // resetting all fields again
    //

    public void inALiteral(final ALiteral l) {
	    super.inALiteral(l);

	    terms = new ArrayList<ITerm>();
    }

    public void inAFunctionTerm(final AFunctionTerm t) {
	    super.inAFunctionTerm(t);

	    inFunc = true;
	    func_terms = new ArrayList<ITerm>();
    }

    public void inALitlist(final ALitlist l) {
	    super.inALitlist(l);

	    literals = new ArrayList<ILiteral>();
    }

    public void inAFact(final AFact f) {
	    super.inAFact(f);

	    literals = new ArrayList<ILiteral>();
	    terms = new ArrayList<ITerm>();
    }

    public void inAQuery(final AQuery q) {
	    super. inAQuery(q);

	    literals = new ArrayList<ILiteral>();
    }

    public void inARule(final ARule r) {
	    super.inARule(r);

	    literals = new ArrayList<ILiteral>();
    }

    //
    // some functions (i don't know the reason for them)
    //
    
    public IAtom getLastFact() {
    	return Factory.BASIC.createAtom(Factory.BASIC.createPredicate("test",0));
    }
    
    public IRule getLastRule() {
    	return Factory.BASIC.createRule(Factory.BASIC.createHead(literals), Factory.BASIC.createBody(literals));
    }

    //
    // functions to transform the nodes
    //
    
    public void outARule(final ARule r) {
    	super.outARule(r);

    	r.getHead().apply(this);
    	final List<ILiteral> head = new ArrayList<ILiteral>(literals);
	r.getBody().apply(this);
	final List<ILiteral> body = new ArrayList<ILiteral>(literals);
	p.addRule(BASIC.createRule(BASIC.createHead(head), BASIC.createBody(body)));
    }
    
    public void outAFact(final AFact f) {
    	super.outAFact(f);

    	p.addFact(literals.get(0).getAtom());
    }
    
    public void outAQuery(final AQuery _q) {
    	super.outAQuery(_q);

    	p.addQuery(BASIC.createQuery(literals));
    }
    
    public void outANegatedLiteral(ANegatedLiteral _l)
    {
    	(literals.get(literals.size() - 1)).setPositive(false);
    }
    
    public void outABinaryBuiltin(final ABinaryBuiltin b) {
    	final String op = b.getTBinOp().getText().trim();
    	final ITerm f = terms.get(0);
    	final ITerm s = terms.get(1);
    	if (op.equals("=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createEqual(f, s)));
    	} else if (op.equals(">")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createGreater(f, s)));
    	} else if (op.equals(">=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createGreaterEqual(f, s)));
    	} else if (op.equals("<")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createLess(f, s)));
    	} else if (op.equals("<=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createLessEqual(f, s)));
    	} else if (op.equals("!=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createUnequal(f, s)));
    	} else {
    		throw new IllegalArgumentException("Couldn't handle the operator " + op);
    	}
    }
    
    public void outATernaryBuiltin(final ATernaryBuiltin b) {
    	throw new UnsupportedOperationException("Ternary builtins cant be created at the moment");
    }
    
	
	public void outABuiltinLiteral(final ABuiltinLiteral l) {
		terms = new ArrayList<ITerm>();
	}


	// TODO: this got to go! won't work in the future
	public ITerm createTerm(final PTerm t) {
		if (t instanceof AVarTerm) {
			return TERM.createVariable(t.toString().trim());
		/*} else if (t instanceof AConstantTerm) {
			return TERM.createString(t.toString().trim());*/
		}
		throw new IllegalArgumentException("Couldn't create a term for " + t);
	}
    
    public void outAPredicate(APredicate _p)
    {
    	super.outAPredicate(_p);
     	IPredicate p = Factory.BASIC.createPredicate(_p.getTId().getText().trim(), terms.size() /*arity*/);
    	IAtom a = Factory.BASIC.createAtom(p, Factory.BASIC.createTuple(terms));
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
    	ILiteral l = Factory.BASIC.createLiteral(true, a); 
    	literals.add(l);
    }
    
    public void outAVarTerm(AVarTerm v) {
    	super.outAVarTerm(v);

	final String n = v.getTVariable().getText().trim();
    	terms.add(TERM.createVariable(n.startsWith("?") ? n.substring(1) : n));
    }

	public void outAFunctionTerm(AFunctionTerm _ft) {
		super.outAFunctionTerm(_ft);
		inFunc = false;
	}
	
	/**
	 * Transforms a intlist to an array of integers.
	 * @param l the intlist to transform
	 * @return the transformed integer array
	 * @throws NullPointerException if the intlist is {@code null}
	 * @throws IllegalArgumentException if somewhere along the transformation an object
	 * 	appears, which vould not be handeled.
	 */
	private static Integer[] transfromIntList(final PIntlist l) {
		if (l == null) {
			throw new NullPointerException("The intlist must not be null");
		}
		
		final List<Integer> ints = new LinkedList<Integer>();
		PIntlist a = l;
		while (a != null) {
			if (a instanceof AIntIntlist) {
				ints.add(Integer.parseInt(((AIntIntlist) a).getTInt().getText().trim()));
				a = null;
			} else if (a instanceof AIntlist) {
				AIntlist il = (AIntlist) a;
				ints.add(Integer.parseInt(il.getTInt().getText().trim()));
				a = il.getIntlist();
			} else {
				throw new IllegalArgumentException("Couldn't handle a object of type " + a.getClass().getName());
			}
		}

		Collections.reverse(ints);
		final Integer[] arr = new Integer[ints.size()];
		return ints.toArray(arr);
	}

	public void outAStringTerm(final AStringTerm st) {
		terms.add(TERM.createString(peeleStr(st.getTStr().toString().trim())));
	}

	public void outAStringlTerm(final AStringlTerm st) {
		terms.add(TERM.createString(peeleStr(st.getTStr().toString().trim())));
	}

	public void outAIntegerTerm(final AIntegerTerm it) {
		terms.add(CONCRETE.createInteger(Integer.parseInt(it.getTInt().toString().trim())));
	}

	public void outAIntegerlTerm(final AIntegerlTerm it) {
		terms.add(CONCRETE.createInteger(Integer.parseInt(it.getTInt().toString().trim())));
	}

	public void outADecimalTerm(final ADecimalTerm dt) {
		terms.add(CONCRETE.createDecimal(Double.parseDouble(dt.getTDec().toString().trim())));
	}

	public void outADecimallTerm(final ADecimallTerm dt) {
		terms.add(CONCRETE.createDecimal(Double.parseDouble(dt.getTDec().toString().trim())));
	}

	public void outASqnameTerm(final ASqnameTerm st) {
		terms.add(CONCRETE.createSqName(st.getTSq().toString().trim()));
	}

	public void outASqnamelTerm(final ASqnamelTerm st) {
		terms.add(CONCRETE.createSqName(st.getTSq().toString().trim()));
	}

	public void outAIriTerm(final AIriTerm i) {
		terms.add(CONCRETE.createIri(peeleStr(i.getTStr().toString().trim())));
	}

	public void outAIrilTerm(final AIrilTerm i) {
		terms.add(CONCRETE.createIri(peeleStr(i.getTStr().toString().trim())));
	}

	public void outABooleanTerm(final ABooleanTerm b) {
		terms.add(CONCRETE.createBoolean(Boolean.parseBoolean(peeleStr(b.getTStr().toString().trim()))));
	}

	public void outADoubleTerm(final ADoubleTerm d) {
		terms.add(CONCRETE.createDouble(Double.parseDouble(d.getTDec().toString().trim())));
	}

	public void outAFloatTerm(final AFloatTerm f) {
		terms.add(CONCRETE.createFloat(Float.parseFloat(f.getTDec().toString().trim())));
	}

	public void outABase64binaryTerm(final ABase64binaryTerm b) {
		terms.add(CONCRETE.createBase64Binary(peeleStr(b.getTStr().getText().trim())));
	}

	public void outAHexbinaryTerm(final AHexbinaryTerm h) {
		terms.add(CONCRETE.createHexBinary(peeleStr(h.getTStr().getText().trim())));
	}

	public void outADateTerm(final ADateTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length != 3) {
			throw new IllegalArgumentException("The number of integers in a date must be 3, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		terms.add(CONCRETE.createDate(params[0], params[1], params[2]));
	}

	public void outADurationTerm(final ADurationTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length != 6) {
			throw new IllegalArgumentException("The number of integers in a duration must be 6, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		terms.add(CONCRETE.createDuration(params[0], params[1], params[2], params[3], params[4], params[5]));
	}

	public void outADatetimeTerm(final ADatetimeTerm d) {
		Integer[] params = transfromIntList(d.getIntlist());
		if (params.length == 6) {
			terms.add(CONCRETE.createDateTime(params[0], params[1], params[2], params[3], params[4], params[5]));
		} else if (params.length == 8) {
			terms.add(CONCRETE.createDateTime(params[0], params[1], params[2], params[3], params[4], params[5], 
						params[6], params[7]));
		} else {
			throw new IllegalArgumentException("The number of integers in a datetime must be 6 or 8, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outATimeTerm(final ATimeTerm t) {
		Integer[] params = transfromIntList(t.getIntlist());
		if (params.length == 3) {
			terms.add(CONCRETE.createTime(params[0], params[1], params[2]));
		} else if (params.length == 5) {
			terms.add(CONCRETE.createTime(params[0], params[1], params[2], params[3], params[4]));
		} else {
			throw new IllegalArgumentException("The number of integers in a time must be 3 or 5, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
	}

	public void outAGyearTerm(final AGyearTerm g) {
		terms.add(CONCRETE.createGYear(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGmonthTerm(final AGmonthTerm g) {
		terms.add(CONCRETE.createGMonth(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGdayTerm(final AGdayTerm g) {
		terms.add(CONCRETE.createGDay(Integer.parseInt(g.getTInt().getText().trim())));
	}

	public void outAGyearmonthTerm(final AGyearmonthTerm g) {
		Integer[] params = transfromIntList(g.getIntlist());
		if (params.length != 2) {
			throw new IllegalArgumentException("The number of integers in a gyearmonth must be 2, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		terms.add(CONCRETE.createGYearMonth(params[0], params[1]));
	}

	public void outAGmonthdayTerm(final AGmonthdayTerm g) {
		Integer[] params = transfromIntList(g.getIntlist());
		if (params.length != 2) {
			throw new IllegalArgumentException("The number of integers in a gmonthday must be 2, but was " + 
					params.length + ": " + Arrays.toString(params));
		}
		terms.add(CONCRETE.createGMonthDay(params[0], params[1]));
	}

	/**
	 * Removes the leading and tailing <code>&amp;'&amp;</code> from a
	 * string.
	 * @param s the string to peele
	 * @return the peeled stirng if the string started and ended with 
	 * 	a <code>&amp;'&amp;</code>, otherwise the input string will be returned.
	 * @throws NullPointerException if the string is <code>null</code>
	 */
	private static String peeleStr(final String s) {
		if(s == null) {
			throw new NullPointerException("The string must not be null");
		}
		return ((s.charAt(0) == '\'') && (s.charAt(s.length() - 1) == '\'')) ? 
			s.substring(1, s.length() - 1) : s;
	}
}

