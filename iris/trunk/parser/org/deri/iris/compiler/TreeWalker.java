/*
 * Integrated Rule Inference System (IRIS):
 * An extensible rule inference system for datalog with extensions by 
 * built-in predicates, default negation (under well-founded semantics), 
 * function symbols and contexts. 
 * 
 * Copyright (C) 2006  Digital Enterprise Research Institute (DERI), 
 * Leopold-Franzens-Universitaet Innsbruck, Technikerstrasse 21a, 
 * A-6020 Innsbruck. Austria.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
 * MA  02110-1301, USA.
 */
package org.deri.iris.compiler;

import static org.deri.iris.factory.Factory.BASIC;
import static org.deri.iris.factory.Factory.TERM;
import static org.deri.iris.factory.Factory.BUILTIN;

import java.util.*;

import org.deri.iris.parser.analysis.DepthFirstAdapter;
import org.deri.iris.parser.node.*;
import org.deri.iris.api.terms.ITerm;
import org.deri.iris.api.*;
import org.deri.iris.api.basics.*;
import org.deri.iris.factory.*;

/**
 * traverses AST generated by SbaleCC and populates RuleSet
 *
 * <pre>
 * Created on 14.11.2005
 * Committed by $Author: richardpoettler $
 * $Source: /tmp/iris-cvsbackup/iris/parser/org/deri/iris/compiler/TreeWalker.java,v $,
 * </pre>
 *
 * @author Francisco Garcia
 *
 * @version $Revision: 1.11 $ $Date: 2006-11-15 09:03:48 $
 */
public class TreeWalker extends DepthFirstAdapter {
    
	private List<ITerm> terms = new ArrayList<ITerm>(); 
	private List<ILiteral> literals = new ArrayList<ILiteral>();
	
    private IEDB p;
	
    public TreeWalker(IEDB p){
        this.p= p;
    }
    
    public IAtom getLastFact() {
    	return Factory.BASIC.createAtom(Factory.BASIC.createPredicate("test",0));
    }
    
    public IRule getLastRule() {
    	return Factory.BASIC.createRule(Factory.BASIC.createHead(literals), Factory.BASIC.createBody(literals));
    }
    
    public void outARule(ARule _r) 
    {
    	super.outARule(_r);
    	// Initialite literals
    	literals = new ArrayList<ILiteral>();
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
    	_r.getPredicate().apply(this);
    	IHead ruleHead = Factory.BASIC.createHead(literals);
    	// Initialite literals
    	literals = new ArrayList<ILiteral>();
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
   	 	_r.getBody().apply(this);
   	 	IBody ruleBody = Factory.BASIC.createBody(literals);
    	IRule r = Factory.BASIC.createRule(ruleHead, ruleBody);
     	p.addRule(r);

    	// Initialite literals
    	literals = new ArrayList<ILiteral>();
    	// Initialite terms
    	terms = new ArrayList<ITerm>();

    }
    
    public void outAFact(AFact _f)
    {
    	super.outAFact(_f);
    	// Initialite literals
    	//literals = new Vector<ILiteral>();
    	// Initialite terms
    	//terms = new Vector<ITerm>();
    	//_f.getPredicate().apply(this);
    	p.addFact(literals.get(0).getAtom());
    	
    	// Initialite literals
    	literals = new ArrayList<ILiteral>();
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
    }
    
    public void outAQuery(AQuery _q)
    {
    	super.outAQuery(_q);
    	// Initialite literals
    	//literals = new Vector<ILiteral>();
    	// Initialite terms
    	//terms = new Vector<ITerm>();
    	//_q.getBody().apply(this);
    	IQuery q = Factory.BASIC.createQuery(literals);
    	p.addQuery(q);
    	// Initialite literals
    	literals = new ArrayList<ILiteral>();
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
    }
    
    public void outANegatedLiteral(ANegatedLiteral _l)
    {
    	(literals.get(literals.size() - 1)).setPositive(false);
    }
    
    public void outABinaryBuiltin(final ABinaryBuiltin b) {
    	final String op = b.getTBinOp().getText().trim();
    	final ITerm f = createTerm(b.getFirst());
    	final ITerm s = createTerm(b.getSecond());
    	if (op.equals("=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createEqual(f, s)));
    	} else if (op.equals(">")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createGreater(f, s)));
    	} else if (op.equals(">=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createGreaterEqual(f, s)));
    	} else if (op.equals("<")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createLess(f, s)));
    	} else if (op.equals("<=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createLessEqual(f, s)));
    	} else if (op.equals("!=")) {
    		literals.add(BASIC.createLiteral(true, BUILTIN.createUnequal(f, s)));
    	} else {
    		throw new IllegalArgumentException("Couldn't handle the operator " + op);
    	}
    }
    
    public void outATernaryBuiltin(final ATernaryBuiltin b) {
    	throw new UnsupportedOperationException("Ternary builtins cant be created at the moment");
    }
    
	
	public void outABuiltinLiteral(final ABuiltinLiteral l) {
		terms = new ArrayList<ITerm>();
	}

    public ITerm createTerm(final PTerm t) {
    	if (t instanceof AVarTerm) {
    		return TERM.createVariable(t.toString().trim());
    	} else if (t instanceof AConstantTerm) {
    		return TERM.createString(t.toString().trim());
    	}
    	throw new IllegalArgumentException("Couldn't create a term for " + t);
    }
    
    public void outAPredicate(APredicate _p)
    {
    	super.outAPredicate(_p);
     	IPredicate p = Factory.BASIC.createPredicate(_p.getTId().getText().trim(), terms.size() /*arity*/);
    	IAtom a = Factory.BASIC.createAtom(p, Factory.BASIC.createTuple(terms));
    	// Initialite terms
    	terms = new ArrayList<ITerm>();
    	ILiteral l = Factory.BASIC.createLiteral(true, a); 
    	literals.add(l);
    }
    
    public void outAConstantTerm(AConstantTerm _ct)
    {
    	super.outAConstantTerm(_ct);
    	ITerm t = Factory.TERM.createString(_ct.getTId().getText().trim());
    	terms.add(t);    	
    }
    
    public void outAVarTerm(AVarTerm _vt)
    {
    	super.outAVarTerm(_vt);
    	ITerm t = Factory.TERM.createVariable(_vt.getTVariable().getText().trim());
    	terms.add(t);
    }

	public void outAFunctionTerm(AFunctionTerm _ft)
	{
		super.outAFunctionTerm(_ft);
		
    	List<ITerm> terms_temporal = terms;
		terms = new ArrayList<ITerm>(); 
		_ft.getParamlist().apply(this);
		ITerm t = Factory.TERM.createConstruct(_ft.getTId().getText().trim(), terms);
		// Delete the terms of the current function from the global terms list
		for (int i = 0; i < terms.size(); i++)
		{
			terms_temporal.remove(terms_temporal.size() - 1);
		}
		// Restore terms
		terms = terms_temporal;
		terms.add(t);
	}

}

