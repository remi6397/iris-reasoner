\documentclass{article}

\usepackage{hyperref}

\title{The IRIS API/user guide}
\date{\today}
\author{Richard P\"ottler}

\begin{document}

\maketitle
\tableofcontents



\section{Intorduction}

\subsection{Purpose}

This document should give you a short introduction to the IRIS reasoner. After
reading this you should understand the principal functionality of iris and be
able to evaluate programs according to your needs.

\subsection{Audience}

Everyone using IRIS should read this document to use it efficiently and to avoid
misunderstandings.

\subsection{Scope}

First of all the overall principle is descriped, what it does, what you put in
and get out. Second the different evaluation strategies are descriped. In the
third part is descriped what IRIS is not able to do and what could go wrong.
Datatypes and builtins are covered shortly in chapter four. And finally a
overview of the API as itself is provided.



\section{Description}

\subsection{What it does}

IRIS evaluates datalog programms consisting of rules and facts and will answer
given queries.

\subsection{What is input}

To `feed' IRIS with rules, facts and queries there are at the moment 2
possibilities: you could create the java objects by hand (described in section
\ref{api} on page \pageref{api}) or you type a datalog program as described in
the datalog grammar guide and let the parser do the work (described in section
\ref{parser} on page \pageref{parser}).

\subsection{What is output}

IRIS will return the variable bindings for the evaluated query.



\section{Evaluation Process}

\subsection{Supported Strategies}

\subsubsection{Naive}

The `Naive' evaluation is a bottom up approach. This means it first computes
the fixed point and then searches for variable substitutions for the query. The
evaluation will be done as long as new tuples for the predicates are generated.

\subsubsection{Semi-Naive}

The `Semi-Naive' algorithm is nearly the same as the same as the `Naive' one
with the difference. In every evaluation process only the new tuples generated
in the previous step are taken as tuples for the relation instead of the
whole relation for this predicate.

\subsubsection{MagicSets}

With the `MagicSets' the rules are first transformed according to the variable
bindings of the query so that the computation of the fixed point is as
restricted as much as possible (see `On the Power of
Magic'\footnote{http://portal.acm.org/citation.cfm?id=28659.28689} by Beeri and
Ramakrishan). After the transformation the `Semi-Naive' evaluation is done.



\section{What can go wrong}

\subsection{Exceptions}

At the moment in IRIS there are following exceptions defined:
\begin{description}
\item[EvaluationException] serves as superclass for all exception which halts
the evaluation process.
\item[ProgramNotStratifiedException] indicates, that the program is not
stratified.
\item[RuleUnsafeException] indicates, that a unsafe rule was detected (see
chapter \ref{safe} on page \pageref{safe})
\end{description}

\subsection{Unsafe rules}
\label{safe}

The algorithm for detecting unsafe rules is taken from `Principles of Database
and Knowledgebase Systems', Ullman, page 105. Generally speaken safe rules are
rules where all variables of the head are limited. Limited means, that it
appears in a positive edb predicate, appears in a positive equation with a
constant of a positive equaltion with a already limited variable. A more precise
explanation of safeness in IRIS can be found on the
homepage\footnote{http://www.iris-reasoner.org/saferules}



\section{Datatypes and builtins}

\subsection{Supported datatypes}
\label{data}

IRIS sticks to the datatypes definded in the WSML
specification\footnote{http://www.wsmo.org/TR/d16/d16.1/v0.21/\#sec:wsml-builtin-datatypes}.
They are also covered in the grammar guide.

\subsection{Builtins}
\label{builtins}

IRIS sticks to the builtins definded in the WSML
specification\footnote{http://www.wsmo.org/TR/d16/d16.1/v0.21/\#sec:wsml-built-ins}
They are also covered in the grammar guide.

\subsection{Behaviour of builtins with incompatible datatypes}
\label{naf}

IRIS has implemented the concept of naf (negation as failure). This means, that
if you apply a operation on two incompatible

\subsection{Arithmetic}

IRIS will convert the result of an arithmetic evaluation to the most precise
type of the both terms. E.g.~will $double + float$ result in a $double$.

\subsection{Negated builtins}

To understand this correctly you got to keep the `negation as failure' form
section \ref{naf} at page \pageref{naf} in mind. First of all the expression is
evaluated as if it would be positive and then the result is negated. This means,
that $\neg X > Y$ is not the same as $X \le Y$. For numbers this might hold,
but if you take 5 for $X$ and `a' for $Y$, the first one will return \verb|true|,
but the second one \verb|false|.



\section{API guide}

\subsection{Creating objects with the Java API}
\label{api}

Most of the objects created in IRIS are created with factories. There's a
factory for every purpose. The most important ones are described below:
\begin{description}
\item[org.deri.iris.api.factory.IProgramFactory] creates programms with or
without initial values.
\item[org.deri.iris.api.factory.IBasicFactory] creates tuples, atoms,
literals, rules and queries.
\item[org.deri.iris.api.factory.ITermFactory] creates variables, strings and
constructed terms.
\item[org.deri.iris.api.factory.IConcreteFactory] creates all other sorts of
terms (see section \ref{data} on page \pageref{data}).
\item[org.deri.iris.api.factory.IBuiltinsFactory] creates builtin atoms provided
by IRIS (sed section \ref{builtins} on page \pageref{builtins}).
\end{description}

The \verb|org.deri.iris.factory.Factory| class holds \verb|static final|
instances of all the factores, so they can be easily \\
(e.g~\verb|import static org.deri.iris.factory.Factory.CONCRETE;|).

For a more complete list of methods, input parameters and return values it is
recommended to read the
javadoc\footnote{http://www.iris-reasoner.org/snapshot/javadoc/}.

\subsection{Creating objects using the parser}
\label{parser}

Instead of creating the java objects by hand, you could also use the \\
\verb|org.deri.iris.compiler.Paser| to parse a datalog program. The grammar
used by the parser is described in the grammar guide.

\subsection{Evaluating a program}

% will be written after the api change

\end{document}
