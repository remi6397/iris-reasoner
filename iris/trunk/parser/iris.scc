Package org.deri.iris.parser;

/************************************************************
 * Helpers                                                  *
 ************************************************************/
Helpers 
    all = [0x0 .. 0xffff];
    //letter = [0x0030 .. 0x312C];
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;

    not_cr_lf = [all - [cr + lf]];
    short_comment = '//' not_cr_lf* eol;
    long_comment_content = [ all - '/' ] | [all - '*'] '/';
    long_comment    =   '/*' long_comment_content * '*/';
    comment = short_comment | long_comment;

    blank = (' ' | tab | eol )+;
    
    delim = ''';
    quoted_content = [ all - delim ] || '\' ''';
    quoted_id = delim quoted_content+ delim;
    
    // builtin symbols
    eq = '=';
    ne = '!' eq;
    add = '+';
    sub = '-';
    mul = '*';
    div = '/';
    lt = '<';
    le = lt eq;
    gt = '>';
    ge = gt eq;
    

/************************************************************
 * Tokens                                                   *
 ************************************************************/  
Tokens
    t_blank = blank;
    t_comment = comment;
    t_dot = '.';
    t_impliedby = ':-';
    t_and = 'and';
    t_not = 'not' | '-' | 'naf' | '!';
    t_comma = ',';
    t_lpar = '(';
    t_rpar = ')';
    t_variable = '?' letter+;
    t_query = '?-';
    t_id = letter+ | quoted_id;
    t_const = quoted_id;
    
    // builtin symbols
    t_bin_op = eq | ne | lt | le | gt | ge; // binary operators
    t_ter_op = add | sub | mul | div; // ternary operators
    t_eq = eq;
                   

    

/************************************************************
 * Ignored Tokens                                           *
 ************************************************************/              
Ignored Tokens  
    t_blank,
    t_comment;  


/************************************************************
 * Productions                                              *
 ************************************************************/  
Productions
    program      = expr* ;
    
    expr         = {rule} rule |
                   {fact} fact |
                   {query} query;
    
    rule 		= predicate t_impliedby body t_dot;
    
    fact 		= predicate t_dot;
    
    query		= t_query body t_dot;
    
    body	 	= literal |
                  {and} body t_and literal |
                  {comma} body t_comma literal;
    
    literal     = {negated} t_not predicate |
                   predicate |
                   {builtin} builtin;
    
    predicate    = t_id paramlist?;
    

    paramlist    = t_lpar termlist? t_rpar;

    termlist     = {term} term |
                   termlist t_comma term;
                   
    term         = {function} t_id paramlist |
                   {var} t_variable |
                   {constant} t_id; // constant
                   
    builtin =		{binary}[first]:term t_bin_op [second]:term |
    				{ternary}[first]:term t_ter_op [second]:term t_eq [third]:term;
    				
