/*
 * MINS (Mins Is Not Silri) A Prolog Egine based on the Silri  
 * 
 * Copyright (C) 1999-2005  Juergen Angele and Stefan Decker
 *                          University of Innsbruck, Austria  
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.deri.mins.compiler;

import java.util.Vector;

import org.deri.mins.*;
import org.deri.mins.parser.analysis.DepthFirstAdapter;
import org.deri.mins.parser.node.*;
import org.deri.mins.terms.*;

/**
 * traverses AST generated by SbaleCC and populates RuleSet
 *
 * <pre>
 * Created on 14.11.2005
 * Committed by $Author: darko $
 * $Source: /tmp/iris-cvsbackup/iris/parser/org/deri/mins/compiler/TreeWalker.java,v $,
 * </pre>
 *
 * @author Holger Lausen
 *
 * @version $Revision: 1.1 $ $Date: 2006-07-19 10:09:51 $
 */
public class TreeWalker extends DepthFirstAdapter {
    
    //current list of terms;
    Vector<Term> terms = new Vector<Term>();
    //current list of bodies;
    Vector<Body> bodies = new Vector<Body>();
    
    Rule rule = null;
    
    private boolean inBody=true;

    private boolean negated=false;
    
    private RuleSet rs;
    private SymbolMap sm;
    
    /**
     * last Rule that has been parsed 
     * @return
     */
    public Rule getLastRule(){
        return rule;
    }
    
    /**
     * last Fact that has been parsed (null if it was not a single fact)
     * @return
     */
    public Fact getLastFact(){
        if (rule.heads.length!=1) return null;
        
        Fact f = new Fact(rule.heads[0].symbol, 
                rule.heads[0].terms);
        return f;
    }

    public TreeWalker(RuleSet rs, SymbolMap sm){
        this.rs=rs;
        this.sm=sm;
    }
    
    @Override
    public void caseAPredicate(APredicate node) {
        String predicateSymbol = node.getTId().getText().trim();
//        System.out.println("  -"+debug);
        if(node.getParamlist() != null){
            node.getParamlist().apply(this);
        }
        
        Term[] termsAsArray = terms.toArray(new Term[terms.size()]);
        terms.clear();
        int predicateNo = sm.getPredicateNo(predicateSymbol,termsAsArray.length);
        if (inBody){
            bodies.add(new Body(predicateNo, negated, termsAsArray));
//            System.out.println("  adding body"+bodies);
        }else{
            Body[] bodiesAsArray = bodies.toArray(new Body[bodies.size()]);
            
            // negative literals are moved to the end of the body; positive literals to the front
            //  for some reason, MINS doesn't do negation properly otherwise
            Body[] newBodiesAsArray = new Body[bodiesAsArray.length];
            int negCounter = bodiesAsArray.length-1;
            int posCounter = 0;
            for (int i = 0; i < bodiesAsArray.length; i++)
            {
            	if (bodiesAsArray[i].isNegated()) {
            		newBodiesAsArray[negCounter] = bodiesAsArray[i];
            		negCounter--;
            	}
            	else {
            		newBodiesAsArray[posCounter] = bodiesAsArray[i];
            		posCounter++;
            	}
            }
            bodiesAsArray = newBodiesAsArray;
            bodies.clear();
            Head head = new Head(predicateNo,termsAsArray);
            Rule r = new Rule(new Head[]{head},bodiesAsArray);
//            System.out.println("head, adding rule"+r);
            if (rs!=null) rs.addRule(r);
            rule = r;
        }
    }

    //f or f(f) (id or fsymbol)
    @Override
    public void caseATerm(ATerm node) {
        int termNo = sm.getConstantNo(node.getTId().getText().trim());
        
        if(node.getParamlist() != null){
            Vector<Term> oldtermlist=terms;
            terms = new Vector<Term>();
            node.getParamlist().apply(this);

            Term[] termsAsArray = terms.toArray(new Term[terms.size()]);
            terms=oldtermlist;
            terms.add(new ConstTerm(termNo, termsAsArray));
        }else{
            terms.add(new ConstTerm(termNo));
        }

    }

    @Override
    public void inAVarTerm(AVarTerm node) {
        String varname = node.getTVariable().getText();
        terms.add(new Variable(sm.getOrAddVariableNo(varname)));
        //System.out.println("--"+varname+"::"+terms);
    }

    /**
     * change order first body then head
     */
    @Override
    public void caseARuleExpr(ARuleExpr node) {
        inBody=true;
        node.getConjunction().apply(this);
        inBody=false;
        node.getPredicate().apply(this);
        sm.setRuleForLocalVars(getLastRule());
    }

    @Override
    public void inANegatedBody(ANegatedBody node) {
        negated=true;
    }

    @Override
    public void outANegatedBody(ANegatedBody node) {
        negated=false;
    }

    @Override
    public void caseAFactExpr(AFactExpr node) {
        inBody=false;
        node.getPredicate().apply(this);    
        inBody=true;
    }

    @Override
    public void caseAQueryExpr(AQueryExpr node) {
        inBody=true;
        node.getConjunction().apply(this);
        inBody=false;

        Body[] bodiesAsArray = bodies.toArray(new Body[bodies.size()]);
        bodies.clear();
        Rule r = new Rule(new Head[]{},bodiesAsArray);
        if (rs!=null) rs.addRule(r);
        rule = r;
        sm.setRuleForLocalVars(getLastRule());
    }
}
